{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"multidim-screening-plain","text":"<p>Multidimensional screening without Numba</p> <ul> <li>Github repository: https://github.com/bsalanie/multidim-screening-plain/</li> <li>Documentation https://bsalanie.github.io/multidim-screening-plain/</li> </ul>"},{"location":"#to-do","title":"TO DO","text":"<ul> <li>optimize the code.</li> </ul>"},{"location":"classes/","title":"<code>classes</code> module","text":""},{"location":"classes/#multidim_screening_plain.classes.ScreeningModel","title":"<code>ScreeningModel</code>  <code>dataclass</code>","text":"<p>Create a model.</p> <p>Attributes:</p> Name Type Description <code>f</code> <code>ndarray</code> <p>an <code>N</code>-vector with the numbers of individuals in each type</p> <code>theta_mat</code> <code>ndarray</code> <p>an <code>(N,d)</code> matrix with the types</p> <code>type_names</code> <code>list[str]</code> <p>a list of <code>d</code> strings with the names of the types</p> <code>contract_varnames</code> <code>list[str]</code> <p>a list of <code>m</code> strings with the names of the contract variables</p> <code>y_minmax</code> <code>ndarray</code> <p>an <code>(m,2)</code> array wth their minimum and maximum possible values</p> <code>params</code> <code>ndarray | None</code> <p>a <code>p</code>-vector with the parameters of the model</p> <code>params_names</code> <code>list | None</code> <p>a list of <code>p</code> strings with the names of the parameters</p> <code>m</code> <code>int</code> <p>the dimension of the contracts</p> <code>model_id</code> <code>str</code> <p>a string with the name of the model</p> <code>resdir</code> <code>Path</code> <p>a Path to the directory where the results are stored</p> <code>plotdir</code> <code>Path</code> <p>a Path to the directory where the plots are stored</p> <code>model_module</code> <code>ModuleType</code> <p>the module with the functions specific to the model</p> <code>b_function</code> <code>Callable</code> <p>the function  that computes <code>b_i(y_j)</code> for all <code>i,j=1,...,n</code></p> <code>S_function</code> <code>Callable</code> <p>the function that computes <code>S_i(y_i)</code> for one type <code>i</code></p> <code>proximal_operator_surplus</code> <code>Callable</code> <p>the proximal operator of the surplus</p> <code>N</code> <code>int</code> <p>the number of types</p> <code>d</code> <code>int</code> <p>their dimension</p> <code>v0</code> <code>ndarray</code> <p>the initial values of the dual variables</p> <code>y_init</code> <code>ndarray</code> <p>the initial values of the contracts</p> <code>free_y</code> <code>list</code> <p>the indices of the  contracts over which we optimize</p> <code>norm_lLambda</code> <code>list</code> <p>the norm of the <code>Lambda</code> function</p> <code>M</code> <code>float</code> <p>the value of the <code>M</code> parameter (for the step size)</p> <code>FB_y</code> <code>ndarray</code> <p>the first-best contracts for the <code>N</code> types</p> Source code in <code>multidim_screening_plain/classes.py</code> <pre><code>@dataclass\nclass ScreeningModel:\n    \"\"\"Create a model.\n\n\n    Attributes:\n        f: an `N`-vector with the numbers of individuals in each type\n        theta_mat: an `(N,d)` matrix with the types\n        type_names: a list of `d` strings with the names of the types\n        contract_varnames: a list of `m` strings with the names of the contract variables\n        y_minmax: an `(m,2)` array wth their minimum and maximum possible values\n        params: a `p`-vector with the parameters of the model\n        params_names: a list of `p` strings with the names of the parameters\n        m: the dimension of the contracts\n        model_id: a string with the name of the model\n        resdir: a Path to the directory where the results are stored\n        plotdir: a Path to the directory where the plots are stored\n        model_module: the module with the functions specific to the model\n        b_function: the function  that computes `b_i(y_j)` for all `i,j=1,...,n`\n        S_function: the function that computes `S_i(y_i)` for one type `i`\n        proximal_operator_surplus: the proximal operator of the surplus\n        N: the number of types\n        d: their dimension\n        v0: the initial values of the dual variables\n        y_init: the initial values of the contracts\n        free_y: the indices of the  contracts over which we optimize\n        norm_lLambda: the norm of the `Lambda` function\n        M: the value of the `M` parameter (for the step size)\n        FB_y: the first-best contracts for the `N` types\n    \"\"\"\n\n    f: np.ndarray\n    theta_mat: np.ndarray\n    type_names: list[str]\n    contract_varnames: list[str]\n    m: int\n    y_minmax: np.ndarray\n    model_id: str\n    resdir: Path\n    plotdir: Path\n    model_module: ModuleType\n    b_function: Callable\n    S_function: Callable\n    proximal_operator_surplus: Callable\n\n    N: int = field(init=False)\n    d: int = field(init=False)  # their dimension\n    v0: np.ndarray = field(init=False)\n    y_init: np.ndarray = field(init=False)\n    free_y: list = field(init=False)\n    norm_Lambda: float = field(init=False)\n    M: float = field(init=False)\n    FB_y: np.ndarray = field(init=False)\n\n    params: np.ndarray | None = None  # the parameters of the model\n    params_names: list | None = None\n\n    def __post_init__(self):\n        self.N, self.d = check_matrix(self.theta_mat)\n        N_f = check_vector(self.f)\n        if N_f != self.N:\n            bs_error_abort(\n                f\"Wrong number of rows of f: {N_f} but we have {self.N} types\"\n            )\n        self.v0 = np.zeros((self.N, self.N))\n\n    def add_first_best(self, y_first_best: np.ndarray):\n        self.FB_y = y_first_best.reshape((self.N, self.m))\n\n    def initialize(self, y_init: np.ndarray, free_y: list, JLy: np.ndarray):\n        self.y_init = y_init\n        self.free_y = free_y\n        self.norm_Lambda = max([spla.svdvals(JLy[i, :, :])[0] for i in range(self.m)])\n        print(\"\\n Free contracts in y_init:\")\n        print(free_y)\n        print(\"\\n Initial contracts:\")\n        print_matrix(contracts_matrix(y_init, self.N))\n\n    def rescale_step(self, mult_fac: float) -&gt; None:\n        self.M = 2.0 * (self.N - 1) * mult_fac\n\n    def __repr__(self) -&gt; str:\n        clstr = f\"\\nModel {self.model_id}: {self.N} {self.d}-dimensional types:\\n\"\n        for j in range(self.d - 1):\n            clstr += f\"    {self.type_names[j]} and \"\n        clstr += f\"    {self.type_names[-1]}\\n\"\n        clstr += f\" and {self.m}-dimensional contracts:\\n\"\n        for j in range(self.m - 1):\n            clstr += f\"    {self.contract_varnames[j]} and \"\n        clstr += f\"    {self.contract_varnames[-1]}\\n\"\n        if self.params is not None:\n            params_names = cast(list, self.params_names)\n            clstr += \"    the model parameters are:\\n\"\n            for name, par in zip(params_names, self.params, strict=True):\n                clstr += f\"    {name}: {par: &gt; 10.3f}\\n\"\n        return clstr + \"\\n\"\n</code></pre>"},{"location":"classes/#multidim_screening_plain.classes.ScreeningResults","title":"<code>ScreeningResults</code>  <code>dataclass</code>","text":"<p>Simulation results.</p> Source code in <code>multidim_screening_plain/classes.py</code> <pre><code>@dataclass\nclass ScreeningResults:\n    \"\"\"Simulation results.\"\"\"\n\n    model: ScreeningModel\n    SB_y: np.ndarray\n    v_mat: np.ndarray\n    IC_binds: np.ndarray\n    rec_primal_residual: list\n    rec_dual_residual: list\n    rec_it_proj: list\n    it: int\n    elapsed: float\n    info_rents: np.ndarray = field(init=False)\n    FB_surplus: np.ndarray = field(init=False)\n    SB_surplus: np.ndarray = field(init=False)\n    additional_results: list | None = None\n    additional_results_names: list | None = None\n    excluded_types: list[bool] = field(init=False)\n    IR_binds: np.ndarray = field(init=False)\n\n    def add_utilities(\n        self, S_first: np.ndarray, U_second: np.ndarray, S_second: np.ndarray\n    ) -&gt; None:\n        \"\"\"Add the utilities to the results.\n\n        Args:\n            S_first: the first best surplus\n            U_second: the second best informational rents\n            S_second: the second best surplus\n        \"\"\"\n        self.FB_surplus = S_first\n        self.SB_surplus = S_second\n        self.info_rents = U_second\n\n    def make_table(self, df_output) -&gt; Table:\n        model = self.model\n        d, m = model.d, model.m\n        table = Table(title=f\"Optimal contracts for {model.model_id}\")\n        theta_names = model.type_names\n        for i in range(d):\n            table.add_column(\n                theta_names[i], justify=\"center\", style=\"red\", no_wrap=True\n            )\n        contract_varnames = model.contract_varnames\n        for j in range(m):\n            table.add_column(\n                f\"FB {contract_varnames[j]}\",\n                justify=\"center\",\n                style=\"blue\",\n                no_wrap=True,\n            )\n        for j in range(m):\n            table.add_column(\n                f\"SB {contract_varnames[j]}\",\n                justify=\"center\",\n                style=\"green\",\n                no_wrap=True,\n            )\n        table.add_column(\"1B surplus\", justify=\"center\", style=\"red\", no_wrap=True)\n        table.add_column(\"2B surplus\", justify=\"center\", style=\"blue\", no_wrap=True)\n        table.add_column(\"Info. rent\", justify=\"center\", style=\"black\", no_wrap=True)\n        table.add_column(\"2B profits\", justify=\"center\", style=\"black\", no_wrap=True)\n\n        elements_list = [df_output[\"theta_0\"]]\n        for i in range(1, d):\n            elements_list.append(df_output[f\"theta_{i}\"])\n        for j in range(m):\n            elements_list.append(df_output[f\"FB_y_{j}\"])\n        for j in range(m):\n            elements_list.append(df_output[f\"y_{j}\"])\n        elements_list.extend(\n            [\n                df_output[\"FB_surplus\"],\n                df_output[\"SB_surplus\"],\n                df_output[\"info_rents\"],\n                df_output[\"SB_profits\"],\n            ]\n        )\n\n        for elements_row in zip(*elements_list, strict=True):\n            gen_row = (f\"{x: &gt; 8.3f}\" for x in elements_row)\n            table.add_row(*gen_row)\n\n        return table\n\n    def output_results(self) -&gt; None:\n        \"\"\"prints the optimal contracts, and saves the results in a dataframe.\"\"\"\n        model = self.model\n        y_mat = self.SB_y\n        df_output = pd.DataFrame(\n            {\n                \"theta_0\": model.theta_mat[:, 0],\n                \"y_0\": y_mat[:, 0],\n                \"FB_y_0\": model.FB_y[:, 0],\n                \"FB_surplus\": self.FB_surplus,\n                \"SB_surplus\": self.SB_surplus,\n                \"info_rents\": self.info_rents,\n            }\n        )\n        d, m = model.d, model.m\n        for i in range(1, d):\n            df_output[f\"theta_{i}\"] = model.theta_mat[:, i]\n        for i in range(1, m):\n            df_output[f\"y_{i}\"] = y_mat[:, i]\n            df_output[f\"FB_y_{i}\"] = model.FB_y[:, i]\n\n        FB_y_columns = [f\"FB_y_{i}\" for i in range(m)]\n        y_columns = [f\"y_{i}\" for i in range(m)]\n        theta_columns = [f\"theta_{i}\" for i in range(d)]\n        df_output = df_output[\n            theta_columns\n            + FB_y_columns\n            + y_columns\n            + [\"FB_surplus\", \"SB_surplus\", \"info_rents\"]\n        ]\n        df_output[\"SB_profits\"] = df_output[\"SB_surplus\"] - df_output[\"info_rents\"]\n\n        if self.additional_results is not None:\n            additional_results_names = cast(list, self.additional_results_names)\n            additional_results = cast(list, self.additional_results)\n            for name, res in zip(\n                additional_results_names, additional_results, strict=True\n            ):\n                df_output[name] = res.round(3)\n\n        console = Console()\n        console.print(\"\\n\" + \"-\" * 80 + \"\\n\", style=\"bold blue\")\n        table = self.make_table(df_output)\n        console.print(table)\n\n        FB_total_profits = df_output[\"FB_surplus\"].sum()\n        SB_total_profits = df_output[\"SB_profits\"].sum()\n        console.print(f\"\\nTotal profits are {FB_total_profits: &gt;.3f} in the first best\")\n        console.print(\n            f\"             and {SB_total_profits: &gt;.3f} in the second best.\\n\"\n        )\n\n        model_resdir = cast(Path, model.resdir)\n        df_output[y_columns].to_csv(\n            model_resdir / \"second_best_contracts.csv\", index=False\n        )\n        np.savetxt(model_resdir / \"IC_binds.txt\", self.IC_binds)\n        np.savetxt(model_resdir / \"IR_binds.txt\", self.IR_binds)\n        np.savetxt(model_resdir / \"v_mat.txt\", self.v_mat)\n\n        df_output.to_csv(model_resdir / \"all_results.csv\", index=False)\n\n        # save the value of the parameters of the model\n        if model.params is not None:\n            params_names = cast(list, model.params_names)\n            params = cast(np.ndarray, model.params)\n            df_params = pd.DataFrame()\n            for k, v in zip(params_names, params, strict=True):\n                df_params[k] = [v]\n            df_params.to_csv(model_resdir / \"params.csv\", index=False)\n\n    def __repr__(self) -&gt; str:\n        model = self.model\n        clstr = model.__repr__()\n        clstr += \"\\n    the optimal contracts are:\\n\"\n        clstr += (\n            \"         type:                         first-best                  \"\n            \" second-best:\\n\"\n        )\n        for i in range(model.N):\n            for j in range(model.d):\n                clstr += f\"{model.theta_mat[i, j]: &gt;8.3f} \"\n            clstr += \":\\t\"\n            for k in range(model.m):\n                clstr += f\"{model.FB_y[i, k]: &gt;8.3f} \"\n            clstr += \";\\t\"\n            for k in range(model.m):\n                clstr += f\"{self.SB_y[i, k]: &gt;8.3f} \"\n            clstr += \"\\n\"\n\n        return clstr + \"\\n\"\n</code></pre>"},{"location":"classes/#multidim_screening_plain.classes.ScreeningResults.add_utilities","title":"<code>add_utilities(S_first, U_second, S_second)</code>","text":"<p>Add the utilities to the results.</p> <p>Parameters:</p> Name Type Description Default <code>S_first</code> <code>ndarray</code> <p>the first best surplus</p> required <code>U_second</code> <code>ndarray</code> <p>the second best informational rents</p> required <code>S_second</code> <code>ndarray</code> <p>the second best surplus</p> required Source code in <code>multidim_screening_plain/classes.py</code> <pre><code>def add_utilities(\n    self, S_first: np.ndarray, U_second: np.ndarray, S_second: np.ndarray\n) -&gt; None:\n    \"\"\"Add the utilities to the results.\n\n    Args:\n        S_first: the first best surplus\n        U_second: the second best informational rents\n        S_second: the second best surplus\n    \"\"\"\n    self.FB_surplus = S_first\n    self.SB_surplus = S_second\n    self.info_rents = U_second\n</code></pre>"},{"location":"classes/#multidim_screening_plain.classes.ScreeningResults.output_results","title":"<code>output_results()</code>","text":"<p>prints the optimal contracts, and saves the results in a dataframe.</p> Source code in <code>multidim_screening_plain/classes.py</code> <pre><code>def output_results(self) -&gt; None:\n    \"\"\"prints the optimal contracts, and saves the results in a dataframe.\"\"\"\n    model = self.model\n    y_mat = self.SB_y\n    df_output = pd.DataFrame(\n        {\n            \"theta_0\": model.theta_mat[:, 0],\n            \"y_0\": y_mat[:, 0],\n            \"FB_y_0\": model.FB_y[:, 0],\n            \"FB_surplus\": self.FB_surplus,\n            \"SB_surplus\": self.SB_surplus,\n            \"info_rents\": self.info_rents,\n        }\n    )\n    d, m = model.d, model.m\n    for i in range(1, d):\n        df_output[f\"theta_{i}\"] = model.theta_mat[:, i]\n    for i in range(1, m):\n        df_output[f\"y_{i}\"] = y_mat[:, i]\n        df_output[f\"FB_y_{i}\"] = model.FB_y[:, i]\n\n    FB_y_columns = [f\"FB_y_{i}\" for i in range(m)]\n    y_columns = [f\"y_{i}\" for i in range(m)]\n    theta_columns = [f\"theta_{i}\" for i in range(d)]\n    df_output = df_output[\n        theta_columns\n        + FB_y_columns\n        + y_columns\n        + [\"FB_surplus\", \"SB_surplus\", \"info_rents\"]\n    ]\n    df_output[\"SB_profits\"] = df_output[\"SB_surplus\"] - df_output[\"info_rents\"]\n\n    if self.additional_results is not None:\n        additional_results_names = cast(list, self.additional_results_names)\n        additional_results = cast(list, self.additional_results)\n        for name, res in zip(\n            additional_results_names, additional_results, strict=True\n        ):\n            df_output[name] = res.round(3)\n\n    console = Console()\n    console.print(\"\\n\" + \"-\" * 80 + \"\\n\", style=\"bold blue\")\n    table = self.make_table(df_output)\n    console.print(table)\n\n    FB_total_profits = df_output[\"FB_surplus\"].sum()\n    SB_total_profits = df_output[\"SB_profits\"].sum()\n    console.print(f\"\\nTotal profits are {FB_total_profits: &gt;.3f} in the first best\")\n    console.print(\n        f\"             and {SB_total_profits: &gt;.3f} in the second best.\\n\"\n    )\n\n    model_resdir = cast(Path, model.resdir)\n    df_output[y_columns].to_csv(\n        model_resdir / \"second_best_contracts.csv\", index=False\n    )\n    np.savetxt(model_resdir / \"IC_binds.txt\", self.IC_binds)\n    np.savetxt(model_resdir / \"IR_binds.txt\", self.IR_binds)\n    np.savetxt(model_resdir / \"v_mat.txt\", self.v_mat)\n\n    df_output.to_csv(model_resdir / \"all_results.csv\", index=False)\n\n    # save the value of the parameters of the model\n    if model.params is not None:\n        params_names = cast(list, model.params_names)\n        params = cast(np.ndarray, model.params)\n        df_params = pd.DataFrame()\n        for k, v in zip(params_names, params, strict=True):\n            df_params[k] = [v]\n        df_params.to_csv(model_resdir / \"params.csv\", index=False)\n</code></pre>"},{"location":"general_plots/","title":"<code>general_plots</code> module","text":""},{"location":"plot_utils/","title":"<code>plot_utils</code> module","text":"<p>Plotting utilities</p>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.melt_for_plots","title":"<code>melt_for_plots(df_all_results, model)</code>","text":"<p>melt the dataframe for plotting purposes</p> <p>Parameters:</p> Name Type Description Default <code>df_all_results</code> <code>DataFrame</code> <p>the dataframe of results</p> required <code>model</code> <code>ScreeningModel</code> <p>the model</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>a new dataframe with first and second best contracts.</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def melt_for_plots(df_all_results: pd.DataFrame, model: ScreeningModel) -&gt; pd.DataFrame:\n    \"\"\"melt the dataframe for plotting purposes\n\n    Args:\n        df_all_results: the dataframe of results\n        model: the model\n\n    Returns:\n        a new dataframe with first and second best contracts.\n    \"\"\"\n    theta_names, contract_names = model.type_names, model.contract_varnames\n    df_first_and_second = pd.DataFrame(\n        {\n            \"Model\": np.concatenate(\n                (np.full(model.N, \"First-best\"), np.full(model.N, \"Second-best\"))\n            ),\n        }\n    )\n    for theta_var in theta_names:\n        df_first_and_second[theta_var] = np.tile(df_all_results[theta_var].values, 2)\n    for contract_var in contract_names:\n        df_first_and_second[contract_var] = np.concatenate(\n            (\n                df_all_results[f\"First-best {contract_var}\"],\n                df_all_results[f\"Second-best {contract_var}\"],\n            )\n        )\n    return df_first_and_second\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.plot_best_contracts_d2_m2","title":"<code>plot_best_contracts_d2_m2(df_first_and_second, theta_names, contract_names, title=None, path=None, **kwargs)</code>","text":"<p>plots the optimal contracts for both first and second best  in the type space the color of a point indicates the first contract variable the size of a point increases with the second contract variable</p> <p>Parameters:</p> Name Type Description Default <code>df_first_and_second</code> <code>DataFrame</code> <p>a dataframe</p> required <code>theta_names</code> <code>list[str]</code> <p>the names of the type characteristics in the dataframe</p> required <code>contract_names</code> <code>list[str]</code> <p>the names of the contract variables in the dataframe</p> required <code>title</code> <code>str | None</code> <p>the title of the plot</p> <code>None</code> <code>path</code> <code>str | None</code> <p>the path to save the plot</p> <code>None</code> <code>kwargs</code> <code>dict | None</code> <p>additional arguments to pass to the plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the two interactive scatterplots.</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def plot_best_contracts_d2_m2(\n    df_first_and_second: pd.DataFrame,\n    theta_names: list[str],\n    contract_names: list[str],\n    title: str | None = None,\n    path: str | None = None,\n    **kwargs: dict | None,\n) -&gt; alt.Chart:\n    \"\"\"plots the optimal contracts for both first and second best  in the type space\n    the color of a point indicates the first contract variable\n    the size of a point increases with the second contract variable\n\n    Args:\n        df_first_and_second: a dataframe\n        theta_names: the names of the type characteristics in the dataframe\n        contract_names: the names of the contract variables in the dataframe\n        title: the title of the plot\n        path: the path to save the plot\n        kwargs: additional arguments to pass to the plot\n\n    Returns:\n          the two interactive scatterplots.\n    \"\"\"\n    contract_var1, contract_var2 = contract_names\n    contract_vals1 = df_first_and_second[contract_var1].values\n    our_colors = set_colors(\n        np.quantile(contract_vals1, np.arange(10) / 10.0).tolist(), interpolate=True\n    )\n    theta_var1, theta_var2 = theta_names\n    theta_vals1 = df_first_and_second[theta_var1].values\n    theta_vals2 = df_first_and_second[theta_var2].values\n    ch = (\n        alt.Chart(df_first_and_second)\n        .mark_point(filled=True)\n        .encode(\n            x=alt.X(\n                f\"{theta_var1}:Q\",\n                title=theta_var1,\n                scale=alt.Scale(domain=set_axis(theta_vals1)),\n            ),\n            y=alt.Y(\n                f\"{theta_var2}:Q\",\n                title=theta_var2,\n                scale=alt.Scale(domain=set_axis(theta_vals2)),\n            ),\n            color=alt.Color(f\"{contract_var1}:Q\", scale=our_colors),\n            size=alt.Size(f\"{contract_var2}:Q\", scale=alt.Scale(range=[50, 500])),\n            tooltip=[theta_var1, theta_var2, contract_var1, contract_var2],\n            facet=alt.Facet(\"Model:N\", columns=2),\n        )\n        .interactive()\n    )\n    if title:\n        ch = ch.properties(title=title)\n    _maybe_save(ch, path)\n    return cast(alt.Chart, ch)\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.plot_constraints_d1","title":"<code>plot_constraints_d1(df_all_results, theta_name, IR_binds, IC_binds, figsize=(5, 5), s=20, title=None, path=None, **kwargs)</code>","text":"<p>the original scatterplot of binding constraints.</p> <p>Parameters:</p> Name Type Description Default <code>df_all_results</code> <code>DataFrame</code> <p>the dataframe of results</p> required <code>IR_binds</code> <code>list</code> <p>the list of types for which  IR binds</p> required <code>IC_binds</code> <code>list</code> <p>the list of pairs (i, j) for which i is indifferent between his contract and j's</p> required <p>Returns:     nothing. Just plots the constraints.</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def plot_constraints_d1(\n    df_all_results: pd.DataFrame,\n    theta_name: str,\n    IR_binds: list,\n    IC_binds: list,\n    figsize: tuple = (5, 5),\n    s: float = 20,\n    title: str | None = None,\n    path: str | None = None,\n    **kwargs: dict | None,\n) -&gt; None:\n    \"\"\"the original scatterplot of binding constraints.\n\n    Args:\n        df_all_results: the dataframe of results\n        IR_binds: the list of types for which  IR binds\n        IC_binds: the list of pairs (i, j) for which i is indifferent between his contract and j's\n    Returns:\n        nothing. Just plots the constraints.\n    \"\"\"\n    thetas = df_all_results[theta_name].values.round(2)\n    IC = \"IC\" if title else \"IC binding\"\n    IR = \"IR\" if title else \"IR binding\"\n    fig, ax = plt.subplots(\n        1, 1, figsize=figsize, subplot_kw=kwargs\n    )  # subplot_kw=dict(aspect='equal',)\n    _ = ax.scatter(\n        thetas[IR_binds],\n        thetas[IR_binds],\n        facecolors=\"w\",\n        edgecolors=\"k\",\n        s=s,\n        zorder=2.5,\n    )\n    _ = ax.scatter([], [], marker=\"&gt;\", c=\"k\", label=IC)\n    _ = ax.scatter(\n        thetas[IR_binds],\n        thetas[IR_binds],\n        label=IR,\n        c=\"tab:green\",\n        s=s,\n        zorder=2.5,\n    )\n\n    for i, j in IC_binds:\n        # if not (i in IR_binds or j in IR_binds):\n        _ = drawArrow_2dim(\n            ax,\n            thetas[i],\n            thetas[j],\n            thetas[i],\n            thetas[j],\n        )\n    _ = ax.set_xlabel(theta_name)\n    _ = ax.set_ylabel(theta_name)\n\n    if title is None:\n        _ = ax.legend(\n            bbox_to_anchor=(0.0, 1.02, 1.0, 0.102),\n            loc=\"lower left\",\n            ncols=2,\n            mode=\"expand\",\n            borderaxespad=0.0,\n        )\n    else:\n        _ = ax.set_title(title)\n        _ = ax.legend(bbox_to_anchor=(1.02, 1.0), loc=\"lower right\")\n\n    if path is not None:\n        fig.savefig(path, bbox_inches=\"tight\", pad_inches=0.05)\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.plot_constraints_d2","title":"<code>plot_constraints_d2(df_all_results, theta_names, IR_binds, IC_binds, figsize=(5, 5), s=20, title=None, path=None, **kwargs)</code>","text":"<p>the original scatterplot of binding constraints.</p> <p>Parameters:</p> Name Type Description Default <code>df_all_results</code> <code>DataFrame</code> <p>the dataframe of results</p> required <code>IR_binds</code> <code>list</code> <p>the list of types for which  IR binds</p> required <code>IC_binds</code> <code>list</code> <p>the list of pairs (i, j) for which i is indifferent between his contract and j's</p> required <p>Returns:     nothing. Just plots the constraints.</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def plot_constraints_d2(\n    df_all_results: pd.DataFrame,\n    theta_names: list[str],\n    IR_binds: list,\n    IC_binds: list,\n    figsize: tuple = (5, 5),\n    s: float = 20,\n    title: str | None = None,\n    path: str | None = None,\n    **kwargs: dict | None,\n) -&gt; None:\n    \"\"\"the original scatterplot of binding constraints.\n\n    Args:\n        df_all_results: the dataframe of results\n        IR_binds: the list of types for which  IR binds\n        IC_binds: the list of pairs (i, j) for which i is indifferent between his contract and j's\n    Returns:\n        nothing. Just plots the constraints.\n    \"\"\"\n    theta_mat = df_all_results[theta_names].values.round(2)\n    IC = \"IC\" if title else \"IC binding\"\n    IR = \"IR\" if title else \"IR binding\"\n    fig, ax = plt.subplots(\n        1, 1, figsize=figsize, subplot_kw=kwargs\n    )  # subplot_kw=dict(aspect='equal',)\n    _ = ax.scatter(\n        theta_mat[:, 0],\n        theta_mat[:, 1],\n        facecolors=\"w\",\n        edgecolors=\"k\",\n        s=s,\n        zorder=2.5,\n    )\n    _ = ax.scatter([], [], marker=\"&gt;\", c=\"k\", label=IC)\n    _ = ax.scatter(\n        theta_mat[:, 0][IR_binds],\n        theta_mat[:, 1][IR_binds],\n        label=IR,\n        c=\"tab:green\",\n        s=s,\n        zorder=2.5,\n    )\n    for i, j in IC_binds:\n        # if not (i in IR_binds or j in IR_binds):\n        _ = drawArrow_2dim(\n            ax,\n            theta_mat[i, 0],\n            theta_mat[j, 0],\n            theta_mat[i, 1],\n            theta_mat[j, 1],\n        )\n    _ = ax.set_xlabel(theta_names[0])\n    _ = ax.set_ylabel(theta_names[1])\n\n    if title is None:\n        _ = ax.legend(\n            bbox_to_anchor=(0.0, 1.02, 1.0, 0.102),\n            loc=\"lower left\",\n            ncols=2,\n            mode=\"expand\",\n            borderaxespad=0.0,\n        )\n    else:\n        _ = ax.set_title(title)\n        _ = ax.legend(bbox_to_anchor=(1.02, 1.0), loc=\"lower right\")\n\n    if path is not None:\n        fig.savefig(path, bbox_inches=\"tight\", pad_inches=0.05)\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.plot_contract_by_type_d2","title":"<code>plot_contract_by_type_d2(df_first_and_second, varname, theta_names, title=None, path=None, **kwargs)</code>","text":"<p>plots the optimal value of a contract variable for both first and second best as a function of the first type characteristic, with different colors by the second type characteristic.</p> <p>Parameters:</p> Name Type Description Default <code>df_first_and_second</code> <code>DataFrame</code> <p>a dataframe</p> required <code>varname</code> <code>str</code> <p>the contract variable</p> required <code>theta_names</code> <code>list[str]</code> <p>the names of the type characteristics in the dataframe</p> required <code>title</code> <code>str | None</code> <p>a title for the plot</p> <code>None</code> <code>path</code> <code>str | None</code> <p>the path to save the plot</p> <code>None</code> <code>kwargs</code> <code>dict | None</code> <p>additional arguments to pass to the plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>Chart</code> <p>as many interactive scatterplots as values of the first type characteristic.</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def plot_contract_by_type_d2(\n    df_first_and_second: pd.DataFrame,\n    varname: str,\n    theta_names: list[str],\n    title: str | None = None,\n    path: str | None = None,\n    **kwargs: dict | None,\n) -&gt; alt.Chart:\n    \"\"\"plots the optimal value of a contract variable for both first and second best\n    as a function of the first type characteristic,\n    with different colors by the second type characteristic.\n\n    Args:\n        df_first_and_second: a dataframe\n        varname: the contract variable\n        theta_names: the names of the type characteristics in the dataframe\n        title: a title for the plot\n        path: the path to save the plot\n        kwargs: additional arguments to pass to the plot\n\n    Returns:\n        as many interactive scatterplots as values of the first type characteristic.\n    \"\"\"\n    df = df_first_and_second.copy()\n    theta_var1, theta_var2 = theta_names\n    theta_vals1 = df[theta_var1].values\n    base = alt.Chart().encode(\n        x=alt.X(\n            f\"{theta_var1}:Q\",\n            scale=alt.Scale(domain=set_axis(theta_vals1)),\n        ),\n        y=alt.Y(f\"{varname}:Q\"),\n        color=alt.Color(\"Model:N\"),\n        tooltip=[theta_var1, theta_var2, varname],\n    )\n    ch_points = base.mark_point(filled=True, size=50)\n    ch_lines = base.mark_line(strokeWidth=0.5)\n    ch = (\n        alt.layer(ch_points, ch_lines, data=df)\n        .properties(width=150, height=120)\n        .interactive()\n        .facet(facet=f\"{theta_var2}:N\", columns=5)\n    ).properties(title=f\"Optimal {varname}\")\n    if title:\n        ch = ch.properties(title=title)\n    _maybe_save(ch, path)\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.plot_contract_models_d1","title":"<code>plot_contract_models_d1(df_first_and_second, varname, theta_name, title=None, path=None, **kwargs)</code>","text":"<p>plots a contract variable for both first and second best as a function of the type.</p> <p>Parameters:</p> Name Type Description Default <code>df_first_and_second</code> <code>DataFrame</code> <p>a dataframe</p> required <code>varname</code> <code>str</code> <p>the contract variable</p> required <code>theta_name</code> <code>str</code> <p>the name of the type in the dataframe</p> required <code>title</code> <code>str | None</code> <p>a title for the plot</p> <code>None</code> <code>path</code> <code>str | None</code> <p>the path to save the plot</p> <code>None</code> <code>kwargs</code> <code>dict | None</code> <p>additional arguments to pass to the plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the two interactive scatterplots.</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def plot_contract_models_d1(\n    df_first_and_second: pd.DataFrame,\n    varname: str,\n    theta_name: str,\n    title: str | None = None,\n    path: str | None = None,\n    **kwargs: dict | None,\n) -&gt; alt.Chart:\n    \"\"\"plots a contract variable for both first and second best\n    as a function of the type.\n\n    Args:\n        df_first_and_second: a dataframe\n        varname: the contract variable\n        theta_name: the name of the type in the dataframe\n        title: a title for the plot\n        path: the path to save the plot\n        kwargs: additional arguments to pass to the plot\n\n    Returns:\n        the two interactive scatterplots.\n    \"\"\"\n    df = df_first_and_second\n    base = alt.Chart().encode(\n        x=alt.X(\n            f\"{theta_name}:Q\",\n            title=theta_name,\n            scale=alt.Scale(domain=set_axis(df[theta_name].values)),\n        ),\n        y=alt.Y(f\"{varname}:Q\"),\n        tooltip=[theta_name, varname],\n    )\n    ch_points = base.mark_point(filled=True, size=50)\n    ch_lines = base.mark_line(strokeWidth=0.5)\n    ch = alt.layer(ch_points, ch_lines, data=df).interactive().facet(column=\"Model:N\")\n    if title:\n        ch = ch.properties(title=title)\n    _maybe_save(ch, path)\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.plot_contract_models_d2","title":"<code>plot_contract_models_d2(df_first_and_second, varname, theta_names, title=None, path=None, **kwargs)</code>","text":"<p>plots a contract variable for both first and second best as a function of the first type characteristic, with different colors by the second type characteristic.</p> <p>Parameters:</p> Name Type Description Default <code>df_first_and_second</code> <code>DataFrame</code> <p>a dataframe</p> required <code>varname</code> <code>str</code> <p>the contract variable</p> required <code>theta_names</code> <code>list[str]</code> <p>the names of the type characteristics in the dataframe</p> required <code>title</code> <code>str | None</code> <p>a title for the plot</p> <code>None</code> <code>path</code> <code>str | None</code> <p>the path to save the plot</p> <code>None</code> <code>kwargs</code> <code>dict | None</code> <p>additional arguments to pass to the plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>Chart</code> <p>the two interactive scatterplots.</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def plot_contract_models_d2(\n    df_first_and_second: pd.DataFrame,\n    varname: str,\n    theta_names: list[str],\n    title: str | None = None,\n    path: str | None = None,\n    **kwargs: dict | None,\n) -&gt; alt.Chart:\n    \"\"\"plots a contract variable for both first and second best\n    as a function of the first type characteristic,\n    with different colors by the second type characteristic.\n\n    Args:\n        df_first_and_second: a dataframe\n        varname: the contract variable\n        theta_names: the names of the type characteristics in the dataframe\n        title: a title for the plot\n        path: the path to save the plot\n        kwargs: additional arguments to pass to the plot\n\n    Returns:\n        the two interactive scatterplots.\n    \"\"\"\n    df = df_first_and_second.copy()\n    theta_var1, theta_var2 = theta_names\n    theta_vals1 = df[theta_var1].values\n    base = alt.Chart().encode(\n        x=alt.X(\n            f\"{theta_var1}:Q\",\n            title=theta_var1,\n            scale=alt.Scale(domain=set_axis(theta_vals1)),\n        ),\n        y=alt.Y(f\"{varname}:Q\"),\n        color=alt.Color(f\"{theta_var2}:Q\"),\n        tooltip=[theta_var1, theta_var2, varname],\n    )\n    ch_points = base.mark_point(filled=True, size=50)\n    ch_lines = base.mark_line(strokeWidth=0.5)\n    ch = alt.layer(ch_points, ch_lines, data=df).interactive().facet(column=\"Model:N\")\n    if title:\n        ch = ch.properties(title=title)\n    _maybe_save(ch, path)\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.plot_second_best_contracts_d2_m2","title":"<code>plot_second_best_contracts_d2_m2(df_first_and_second, theta_names, contract_names, title=None, cmap_label=None, path=None, figsize=(5, 5), **kwargs)</code>","text":"<p>the original scatterplot  of only the second-best contracts in the type space</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def plot_second_best_contracts_d2_m2(\n    df_first_and_second: pd.DataFrame,\n    theta_names: list[str],\n    contract_names: list[str],\n    title: str | None = None,\n    cmap_label: str | None = None,\n    path: str | None = None,\n    figsize: tuple[int, int] = (5, 5),\n    **kwargs: dict | None,\n) -&gt; None:\n    \"\"\"the original scatterplot  of only the second-best contracts in the type space\"\"\"\n    theta_var1, theta_var2 = theta_names\n    df_second = df_first_and_second.query('Model == \"Second-best\"')\n    fig, ax = plt.subplots(1, 1, figsize=figsize, subplot_kw=kwargs)\n    _ = ax.set_xlabel(theta_var1)\n    _ = ax.set_ylabel(theta_var2)\n    if title:\n        _ = ax.set_title(title)\n    theta_mat = df_second[theta_names].values\n    y_mat = df_second[contract_names].values\n    min1, max1 = np.min(y_mat[:, 1]), np.max(y_mat[:, 1])\n    scatter = ax.scatter(\n        theta_mat[:, 0],\n        theta_mat[:, 1],\n        s=(y_mat[:, 1] - min1) / (max1 - min1) * 200 + 10,\n        c=y_mat[:, 0],\n    )\n    _ = fig.colorbar(scatter, label=cmap_label)\n    if path is not None:\n        fig.savefig(path, bbox_inches=\"tight\", pad_inches=0.05)\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.plot_y_range_m1","title":"<code>plot_y_range_m1(df_first_and_second, contract_name, title=None, path=None, **kwargs)</code>","text":"<p>the optimal contracts for both first and second best in contract space</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def plot_y_range_m1(\n    df_first_and_second: pd.DataFrame,\n    contract_name: str,\n    title: str | None = None,\n    path: str | None = None,\n    **kwargs: dict | None,\n) -&gt; None:\n    \"\"\"the optimal contracts for both first and second best in contract space\"\"\"\n    ch = (\n        alt.Chart(df_first_and_second)\n        .mark_point()\n        .encode(x=alt.X(f\"{contract_name}:Q\"), color=\"Model:N\")\n    )\n    if title:\n        ch = ch.properties(title=title)\n    _maybe_save(ch, path)\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.plot_y_range_m2","title":"<code>plot_y_range_m2(df_first_and_second, contract_names, figsize=(5, 5), s=20, title=None, path=None, **kwargs)</code>","text":"<p>the supposed stingray: the optimal contracts for both first and second best in contract space</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def plot_y_range_m2(\n    df_first_and_second: pd.DataFrame,\n    contract_names: list[str],\n    figsize: tuple[int, int] = (5, 5),\n    s: int = 20,\n    title: str | None = None,\n    path: str | None = None,\n    **kwargs: dict | None,\n) -&gt; None:\n    \"\"\"the supposed stingray: the optimal contracts for both first and second best in contract space\"\"\"\n    first = df_first_and_second.query('Model == \"First-best\"')[contract_names]\n    second = df_first_and_second.query('Model == \"Second-best\"')[contract_names]\n\n    # # discard y1 = 1\n    # second = second.query(\"Copay &lt; 0.99\")\n    y_0_name, y_1_name = contract_names[0], contract_names[1]\n    fig, ax = plt.subplots(\n        1, 1, figsize=figsize, subplot_kw=kwargs\n    )  # subplot_kw=dict(aspect='equal',)\n    _ = ax.scatter(\n        second[y_0_name].values,\n        second[y_1_name].values,\n        color=\"tab:blue\",\n        alpha=0.5,\n        s=s,\n        label=\"Second-best\",\n    )\n    _ = ax.scatter(\n        first[y_0_name].values,\n        first[y_1_name].values,\n        color=\"tab:pink\",\n        s=s,\n        label=\"First-best\",\n    )\n    _ = ax.set_xlabel(y_0_name)\n    _ = ax.set_ylabel(y_1_name)\n    _ = ax.set_title(title)\n    if path is not None:\n        fig.savefig(path, bbox_inches=\"tight\", pad_inches=0.05)\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.set_axis","title":"<code>set_axis(variable, margin=0.05)</code>","text":"<p>sets the axis for a plot with a margin</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>ndarray</code> <p>the values of the variable</p> required <code>margin</code> <code>float</code> <p>the margin to add, a fraction of the range of the variable</p> <code>0.05</code> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>the min and max for the axis.</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def set_axis(variable: np.ndarray, margin: float = 0.05) -&gt; tuple[float, float]:\n    \"\"\"sets the axis for a plot with a margin\n\n    Args:\n        variable: the values of the variable\n        margin: the margin to add, a fraction of the range of the variable\n\n    Returns:\n        the min and max for the axis.\n    \"\"\"\n    x_min, x_max = variable.min(), variable.max()\n    scaled_diff = margin * (x_max - x_min)\n    x_min -= scaled_diff\n    x_max += scaled_diff\n    return x_min, x_max\n</code></pre>"},{"location":"plot_utils/#multidim_screening_plain.plot_utils.set_colors","title":"<code>set_colors(list_vals, interpolate=False)</code>","text":"<p>sets the colors at values of a variable.</p> <p>Parameters:</p> Name Type Description Default <code>list_vals</code> <code>list[Any]</code> <p>the values of the variable</p> required <code>interpolate</code> <code>bool</code> <p>whether we interpolate</p> <code>False</code> <p>Returns:</p> Type Description <code>Scale</code> <p>the color scheme.</p> Source code in <code>multidim_screening_plain/plot_utils.py</code> <pre><code>def set_colors(list_vals: list[Any], interpolate: bool = False) -&gt; alt.Scale:\n    \"\"\"sets the colors at values of a variable.\n\n    Args:\n        list_vals: the values of the variable\n        interpolate: whether we interpolate\n\n    Returns:\n        the color scheme.\n    \"\"\"\n    n_vals = len(list_vals)\n    list_colors = [\n        \"red\",\n        \"lightred\",\n        \"orange\",\n        \"yellow\",\n        \"lightgreen\",\n        \"green\",\n        \"lightblue\",\n        \"darkblue\",\n        \"violet\",\n        \"black\",\n    ]\n    if n_vals == 3:\n        list_colors = [list_colors[i] for i in [0, 5, 7]]\n    elif n_vals == 4:\n        list_colors = [list_colors[i] for i in [0, 3, 6, 9]]\n    elif n_vals == 5:\n        list_colors = [list_colors[i] for i in [0, 2, 4, 6, 8]]\n    elif n_vals == 7:\n        list_colors = [list_colors[i] for i in [0, 1, 2, 4, 6, 8, 9]]\n    if interpolate:\n        our_colors = alt.Scale(domain=list_vals, range=list_colors, interpolate=\"rgb\")\n    else:\n        our_colors = alt.Scale(domain=list_vals, range=list_colors)\n\n    return our_colors\n</code></pre>"},{"location":"setup/","title":"<code>setup</code> module","text":"<p>This sets up the model based in the configuration read from <code>config.env</code>.</p> <p>A module <code>model_name.py</code> should provide the model-dependent functions and parameters:</p> <ul> <li> <p><code>create_initial_contracts</code>: initial values for the contracts, and chooses the types for whom we optimize contracts</p> </li> <li> <p><code>b_fun</code>: computes <code>b_i(y_j)</code> for all pairs of types <code>i</code> and  contracts <code>y_j</code>, and its derivatives wrt to all dimensions of the contracts</p> </li> <li> <p><code>S_fun</code>: computes <code>S_i(y_i)</code> for a type <code>i</code> and their contract <code>y_i</code>, and its derivatives wrt to all dimensions of the contract</p> </li> <li> <p><code>proximal_operator</code>: the proximal operator of the surplus function</p> </li> <li> <p><code>additional_results</code>: additional results to be added to the <code>ScreeningResults</code> object</p> </li> <li> <p><code>plot_results</code>: plots the results.</p> </li> </ul> <p>We use <code>importlib</code> to import the model-dependent module.</p>"},{"location":"setup/#multidim_screening_plain.setup.setup_model","title":"<code>setup_model(model_config, model_type, model_instance)</code>","text":"<p>initializes the <code>ScreeningModel</code> object: fills in the dimensions, the numbers in each type, the characteristics of the types, the model parameters, and the directories.</p> <p>Parameters:</p> Name Type Description Default <code>model_config</code> <code>dict</code> <p>the dictionary read from 'config.env'</p> required <code>model_type</code> <code>str</code> <p>the first command line argument, e.g. \"insurance\"</p> required <code>model_instance</code> <code>str</code> <p>the second command line argument, e.g. \"d2_m2\"</p> required <p>Returns:</p> Type Description <code>ScreeningModel</code> <p>the <code>ScreeningModel</code> object</p> Source code in <code>multidim_screening_plain/setup.py</code> <pre><code>def setup_model(\n    model_config: dict, model_type: str, model_instance: str\n) -&gt; ScreeningModel:\n    \"\"\"initializes the `ScreeningModel` object:\n    fills in the dimensions, the numbers in each type, the characteristics of the types,\n    the model parameters, and the directories.\n\n    Args:\n        model_config: the dictionary read from 'config.env'\n        model_type: the first command line argument, e.g. \"insurance\"\n        model_instance: the second command line argument, e.g. \"d2_m2\"\n\n    Returns:\n        the `ScreeningModel` object\n    \"\"\"\n    model_name = f\"{model_type}_{model_instance}\"\n    print_stars(f\"Running model {model_name}\")\n\n    # first we deal with the types\n    d = int(cast(str, model_config[\"DIMENSION_TYPES\"]))\n    type_names = parse_string(\n        cast(str, model_config[\"TYPES_NAMES\"]), d, \",\", \"type names\", \"str\"\n    )\n    str_dims_grid = cast(str, model_config[\"TYPES_GRID_SIZE\"])\n    dims_grid = parse_string(str_dims_grid, d, \"x\", \"types\", \"int\")\n    N = np.prod(dims_grid)  # number of types\n    # the grid of types\n    str_grid_mins = cast(str, model_config[\"TYPES_MINIMA\"])\n    grid_mins = parse_string(str_grid_mins, d, \",\", \"minima of types\", \"float\")\n    str_grid_maxs = cast(str, model_config[\"TYPES_MAXIMA\"])\n    grid_maxs = parse_string(str_grid_maxs, d, \",\", \"maxima of types\", \"float\")\n    theta: list[np.ndarray] = [np.zeros(1)] * d\n    type_distrib = cast(str, model_config[\"TYPES_DISTRIBUTION\"])\n    if type_distrib == \"uniform\":\n        f = np.ones(N)  # weights of distribution\n        for j in range(d):\n            if grid_mins[j] &gt;= grid_maxs[j]:\n                bs_error_abort(\n                    f\"Wrong bounds for the types: {grid_mins[j]} &gt;= {grid_maxs[j]}\"\n                )\n            else:\n                print(\n                    f\"Dimension {j+1} of the types: from {grid_mins[j]} to\"\n                    f\" {grid_maxs[j]}\"\n                )\n                theta[j] = np.linspace(grid_mins[j], grid_maxs[j], num=dims_grid[j])\n    else:\n        bs_error_abort(\n            f\"Unknown distribution of types: {type_distrib}; only uniform is\"\n            \" implemented.\"\n        )\n    theta_mat = make_grid(theta)  # an (N,d) matrix\n\n    # dimension of contracts\n    m = int(cast(str, model_config[\"NUMBER_CONTRACT_VARIABLES\"]))\n    contract_varnames = parse_string(\n        cast(str, model_config[\"CONTRACT_VARIABLE_NAMES\"]),\n        m,\n        \",\",\n        \"contract variable names\",\n        \"str\",\n    )\n    str_contract_mins = cast(str, model_config[\"CONTRACT_MINIMA\"])\n    contract_mins = parse_string(\n        str_contract_mins, m, \",\", \"minima of contract variables\", \"float\"\n    )\n    str_contract_maxs = cast(str, model_config[\"CONTRACT_MAXIMA\"])\n    contract_maxs = parse_string(\n        str_contract_maxs, m, \",\", \"maxima of contract variables\", \"float\"\n    )\n    y_minmax = np.column_stack((contract_mins, contract_maxs))\n\n    suffix = \"\"\n    model_id = f\"{model_name}_{str_dims_grid}{suffix}\"\n    resdir = mkdir_if_needed(results_dir / model_type / model_instance / model_id)\n    plotdir = mkdir_if_needed(resdir / \"plots\")\n    print(f\"\\nResults will be saved in {resdir}\")\n    print(f\"Plots will be saved in {plotdir}\\n\")\n\n    # model parameters\n    n_params = int(cast(str, model_config[\"NUMBER_PARAMETERS\"]))\n    if n_params &gt; 0:\n        params = parse_string(\n            cast(str, model_config[\"PARAMETERS\"]),\n            n_params,\n            \",\",\n            \"parameters\",\n            \"float\",\n        )\n        params_names = parse_string(\n            cast(str, model_config[\"PARAMETER_NAMES\"]),\n            n_params,\n            \",\",\n            \"parameter names\",\n            \"str\",\n        ).tolist()\n    else:\n        params = None\n        params_names = None\n\n    model_module = importlib.import_module(\n        f\".{model_type}.{model_instance}.{model_name}\",\n        package=\"multidim_screening_plain\",\n    )\n    return ScreeningModel(\n        f=f,\n        model_id=model_id,\n        theta_mat=theta_mat,\n        type_names=type_names.tolist(),\n        contract_varnames=contract_varnames.tolist(),\n        y_minmax=y_minmax,\n        params=params,\n        params_names=params_names,\n        m=m,\n        resdir=resdir,\n        plotdir=plotdir,\n        model_module=model_module,\n        proximal_operator_surplus=model_module.proximal_operator,\n        b_function=model_module.b_fun,\n        S_function=model_module.S_fun,\n    )\n</code></pre>"},{"location":"solver/","title":"<code>solver</code> module","text":"<p>Algorithm for multidimensional screening</p>"},{"location":"solver/#multidim_screening_plain.solver.D_mul","title":"<code>D_mul(v)</code>","text":"<p>computes <code>D v</code></p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>an <code>N</code>-vector</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>an \\(N^d\\)-vector</p> Source code in <code>multidim_screening_plain/solver.py</code> <pre><code>def D_mul(v: np.ndarray) -&gt; np.ndarray:\n    \"\"\"computes `D v`\n\n    Args:\n        v: an `N`-vector\n\n    Returns:\n        an $N^d$-vector\n    \"\"\"\n    N = v.size\n    return np.add.outer(v, -v).reshape(N * N)\n</code></pre>"},{"location":"solver/#multidim_screening_plain.solver.D_star","title":"<code>D_star(v_mat)</code>","text":"<p>computes \\(D^\u0007st v\\)</p> <p>Parameters:</p> Name Type Description Default <code>v_mat</code> <code>ndarray</code> <p>an \\((N, N)\\)-matrix</p> required <p>Returns:</p> Type Description <code>Any</code> <p>an <code>N</code>-vector</p> Source code in <code>multidim_screening_plain/solver.py</code> <pre><code>def D_star(v_mat: np.ndarray) -&gt; Any:\n    \"\"\"computes $D^\\ast v$\n\n    Args:\n        v_mat: an $(N, N)$-matrix\n\n    Returns:\n        an `N`-vector\n    \"\"\"\n    return np.sum(v_mat, 1) - np.sum(v_mat, 0)\n</code></pre>"},{"location":"solver/#multidim_screening_plain.solver.JLambda","title":"<code>JLambda(model, y)</code>","text":"<p>computes <code>Lambda'_{ij}(y) = b'_i(y_j)-b'_j(y_j)</code></p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ScreeningModel</code> <p>the ScreeningModel</p> required <code>y</code> <code>ndarray</code> <p>the contracts for all types, an array of size <code>m N</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>an <code>(m, N, N)</code> array.</p> Source code in <code>multidim_screening_plain/solver.py</code> <pre><code>def JLambda(model: ScreeningModel, y: np.ndarray) -&gt; np.ndarray:\n    \"\"\"computes `Lambda'_{ij}(y) = b'_i(y_j)-b'_j(y_j)`\n\n    Args:\n        model: the ScreeningModel\n        y: the contracts for all types, an array of size `m N`\n\n    Returns:\n        an `(m, N, N)` array.\n    \"\"\"\n    b_function = model.b_function\n    N, m = model.N, model.m\n    # we compute the (N, N) matrices db_i/dy_0(y_j) and db_i/dy_1(y_j)\n    _, db_vals = b_function(model, y, gr=True)\n    J = np.zeros((m, N, N))\n    for i in range(m):\n        db_vals_i = db_vals[i, :, :]\n        J[i, :, :] = db_vals_i - np.diag(db_vals_i)\n    return J\n</code></pre>"},{"location":"solver/#multidim_screening_plain.solver.compute_utilities","title":"<code>compute_utilities(results, tol_fp=1e-06)</code>","text":"<p>Computes the rents for each type using the iterative algorithm <code>T_{Lambda}</code>   of Prop 2</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>ScreeningResults</code> <p>ScreeningResults</p> required <code>tol_fp</code> <code>float</code> <p>tolerance for fixed point</p> <code>1e-06</code> <p>Returns:</p> Name Type Description <code>S_first</code> <code>ThreeArrays</code> <p>an <code>N</code>-vector of the values of the joint surplus in the first-best</p> <code>U_second</code> <code>ThreeArrays</code> <p>an <code>N</code>-vector of informational rents in the second-best</p> <code>S_second</code> <code>ThreeArrays</code> <p>an <code>N</code>-vector of the values of the joint surplus in the second-best</p> Source code in <code>multidim_screening_plain/solver.py</code> <pre><code>def compute_utilities(\n    results: ScreeningResults,\n    tol_fp: float = 1e-6,\n) -&gt; ThreeArrays:\n    \"\"\"Computes the rents for each type using the iterative algorithm `T_{Lambda}`\n      of Prop 2\n\n    Args:\n        results: ScreeningResults\n        tol_fp: tolerance for fixed point\n\n    Returns:\n        S_first: an `N`-vector of the values of the joint surplus in the first-best\n        U_second: an `N`-vector of informational rents in the second-best\n        S_second: an `N`-vector of the values of the joint surplus in the second-best\n    \"\"\"\n    model = results.model\n    N = model.N\n    S_function = model.S_function\n    y_first_best = model.FB_y\n    theta_mat = model.theta_mat\n    S_first = np.zeros(N)\n    S_second = np.zeros(N)\n    y_second_best = results.SB_y\n    for i in range(N):\n        theta = theta_mat[i, :]\n        S_first[i] = S_function(model, y_first_best[i, :], theta=theta)\n        S_second[i] = S_function(model, y_second_best[i, :], theta=theta)\n    y_second = contracts_vector(y_second_best)\n    Lambda_vals = nlLambda(model, y_second).reshape((N, N))\n\n    U_second = U_old = np.zeros(N)\n    dU = np.inf\n    it_max = N\n    it = 0\n    while dU &gt; tol_fp and it &lt; it_max:\n        for i in range(N):\n            U_second[i] = np.max(Lambda_vals[i, :] + U_old)\n        dU = npmaxabs(U_second - U_old)\n        U_old = U_second\n        it += 1\n\n    tol = 1e-4\n    results.IR_binds = np.argwhere(U_second &lt; tol).flatten()\n\n    return S_first, U_second, S_second\n</code></pre>"},{"location":"solver/#multidim_screening_plain.solver.construct_D","title":"<code>construct_D(N)</code>","text":"<p>Constructs the matrix <code>D</code> and the step size for the projection</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>number of types</p> required <p>Returns:</p> Name Type Description <code>D</code> <code>csr_matrix</code> <p>the <code>(N^2, N)</code> matrix <code>D</code></p> <code>gamma_proj</code> <code>float</code> <p>the step size</p> Source code in <code>multidim_screening_plain/solver.py</code> <pre><code>def construct_D(N: int) -&gt; tuple[sparse.csr_matrix, float]:\n    \"\"\"Constructs the matrix `D` and the step size for the projection\n\n    Args:\n        N: number of types\n\n    Returns:\n        D: the `(N^2, N)` matrix `D`\n        gamma_proj: the step size\n    \"\"\"\n    D = sparse.vstack(\n        [\n            -sparse.eye(N)\n            + sparse.coo_matrix(\n                (\n                    np.ones(N),\n                    (\n                        np.arange(N),\n                        i * np.ones(N, dtype=int),\n                    ),\n                ),\n                shape=(N, N),\n            )\n            for i in range(N)\n        ],\n        format=\"csr\",\n    )\n    D = D[range(N * N)]\n    _, s_proj, _ = sparse.linalg.svds(D, k=1, solver=\"arpack\")  # norm_Lambda = s[0]\n    gamma_proj = 1 / s_proj[0] ** 2\n    return D, gamma_proj\n</code></pre>"},{"location":"solver/#multidim_screening_plain.solver.get_first_best","title":"<code>get_first_best(model)</code>","text":"<p>computes the first-best contracts for all types</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ScreeningModel</code> <p>the screening model</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>the <code>(N, m)</code> matrix of first-best contracts.</p> Source code in <code>multidim_screening_plain/solver.py</code> <pre><code>def get_first_best(model: ScreeningModel) -&gt; np.ndarray:\n    \"\"\"computes the first-best contracts for all types\n\n    Args:\n        model: the screening model\n\n    Returns:\n        the `(N, m)` matrix of first-best contracts.\n    \"\"\"\n    prox_operator = model.proximal_operator_surplus\n    theta_mat = model.theta_mat\n    N, m = model.N, model.m\n\n    y_first = np.empty((N, m))\n    for i in range(N):\n        theta_i = theta_mat[i, :]\n        y_first[i, :] = prox_operator(model, theta_i)\n        if i % 10 == 0:\n            print(f\"\\n Done {i=} types out of {N}\")\n            print(f\"\\ni={i}:  theta is\")\n            print_row(theta_mat, i)\n            print(\"\\t\\t first-best contract:\")\n            print_row(y_first, i)\n\n    df_first_best_contracts = pd.DataFrame(\n        y_first.round(6), columns=[f\"y_{i}\" for i in range(m)]\n    )\n    df_first_best_contracts.to_csv(\n        cast(Path, model.resdir) / \"first_best_contracts.csv\", index=False\n    )\n    return cast(np.ndarray, y_first)\n</code></pre>"},{"location":"solver/#multidim_screening_plain.solver.make_LTv","title":"<code>make_LTv(v_mat, JLy)</code>","text":"<p>creates <code>(Lambda'(y))* v</code></p> <p>Parameters:</p> Name Type Description Default <code>v_mat</code> <code>ndarray</code> <p>an <code>(N, N)</code> matrix</p> required <code>JLy</code> <code>ndarray</code> <p>an <code>(m,N,N)</code> array</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>an <code>m N</code>-vector</p> Source code in <code>multidim_screening_plain/solver.py</code> <pre><code>def make_LTv(v_mat: np.ndarray, JLy: np.ndarray) -&gt; np.ndarray:\n    \"\"\"creates `(Lambda'(y))* v`\n\n    Args:\n        v_mat: an `(N, N)` matrix\n        JLy: an `(m,N,N)` array\n\n    Returns:\n        an `m N`-vector\n    \"\"\"\n    m, N = JLy.shape[:-1]\n    LTv = np.empty(m * N)\n    iN = 0\n    for i in range(m):\n        jN = iN + N\n        LTv[iN:jN] = np.sum(JLy[i, :, :] * v_mat, 0)\n        iN = jN\n    return LTv\n</code></pre>"},{"location":"solver/#multidim_screening_plain.solver.nlLambda","title":"<code>nlLambda(model, y)</code>","text":"<p>computes <code>Lambda_{ij}(y) = b_i(y_j)-b_j(y_j)</code></p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>ndarray</code> <p>the contracts, a vector of size <code>m N</code> (<code>y_0</code> then <code>y_1</code> etc)</p> required <p>Returns:</p> Type Description <code>Any</code> <p>an <code>(N,N)</code> matrix.</p> Source code in <code>multidim_screening_plain/solver.py</code> <pre><code>def nlLambda(\n    model: ScreeningModel,\n    y: np.ndarray,\n) -&gt; Any:\n    \"\"\"computes `Lambda_{ij}(y) = b_i(y_j)-b_j(y_j)`\n\n    Args:\n        y: the contracts, a vector of size `m N` (`y_0` then `y_1` etc)\n\n    Returns:\n        an `(N,N)` matrix.\n    \"\"\"\n    b_function = model.b_function\n    N = model.N\n    b_vals = b_function(model, y)\n    db = b_vals\n    for j in range(N):\n        db[:, j] -= b_vals[j, j]\n    return db\n</code></pre>"},{"location":"solver/#multidim_screening_plain.solver.proj_K","title":"<code>proj_K(model, w, lamb, gamma_proj, warmstart=True, atol_proj=1e-06, rtol_proj=0.0001)</code>","text":"<p>Projection of <code>w</code> onto <code>K</code> by Fast Projected Gradient</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ScreeningModel</code> <p>the model</p> required <code>w</code> <code>ndarray</code> <p>an <code>(N * N)</code> vector</p> required <code>lamb</code> <code>ndarray</code> <p>an <code>N</code> vector, the previous value</p> required <code>warmstart</code> <code>bool</code> <p>whether to start from the previous <code>lamb</code></p> <code>True</code> <code>gamma_proj</code> <code>float</code> <p>the step size</p> required <code>atol_proj</code> <code>float</code> <p>absolute tolerance</p> <code>1e-06</code> <code>rtol_proj</code> <code>float</code> <p>relative tolerance</p> <code>0.0001</code> <p>Returns:     the projection, the value of <code>lamb</code>,     the number of iterations, and a status code</p> Source code in <code>multidim_screening_plain/solver.py</code> <pre><code>def proj_K(\n    model: ScreeningModel,\n    w: np.ndarray,\n    lamb: np.ndarray,\n    gamma_proj: float,\n    warmstart: bool = True,\n    atol_proj: float = 1e-6,\n    rtol_proj: float = 1e-4,\n) -&gt; tuple[np.ndarray, np.ndarray, int, int] | None:\n    \"\"\"Projection of `w` onto `K` by Fast Projected Gradient\n\n    Args:\n        model: the model\n        w: an `(N * N)` vector\n        lamb: an `N` vector, the previous value\n        warmstart: whether to start from the previous `lamb`\n        gamma_proj: the step size\n        atol_proj: absolute tolerance\n        rtol_proj: relative tolerance\n    Returns:\n        the projection, the value of `lamb`,\n        the number of iterations, and a status code\n    \"\"\"\n    N = model.N\n    eta = model.f\n\n    it_max = 100_000\n    lamb1 = lamb if warmstart else np.zeros(N)\n    lamb_extra = lamb1\n    converged: bool = False\n    it = 0\n    c_tol = rtol_proj * eta + atol_proj\n    while it &lt; it_max and not converged:\n        lamb_old = lamb1\n        Dw = np.clip(w - D_mul(lamb_extra), 0.0, None).reshape((N, N))\n        lamb1 = np.clip(lamb_extra - gamma_proj * (eta - D_star(Dw)), 0.0, None)\n        v = np.clip(w - D_mul(lamb1), 0.0, None)\n        constraints = D_star(v.reshape((N, N))) - eta\n        lamb_constraints = lamb1 @ constraints\n        dvw = v - w\n        dvw2 = np.sum(dvw * dvw)\n        obj = 0.5 * dvw2 + lamb_constraints\n        o_tol = rtol_proj * obj + atol_proj\n        converged = cast(\n            bool, np.all(constraints &lt; c_tol) and abs(lamb_constraints) &lt; o_tol\n        )\n        lamb_extra = lamb1 + (it - 1.0) / (it + 3.0) * (lamb1 - lamb_old)\n\n    if converged:\n        return v, lamb1, it, converged\n    else:\n        bs_error_abort(\"failed to converge.\")\n        return None\n</code></pre>"},{"location":"solver/#multidim_screening_plain.solver.prox_minusS","title":"<code>prox_minusS(model, z, tau, y_current, fix_top=False, free_y=None)</code>","text":"<p>Proximal operator of <code>-S(y) = sum_i f_i H(y_i, theta_i)</code></p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ScreeningModel</code> <p>the model</p> required <code>z</code> <code>ndarray</code> <p>an <code>m N</code>-vector</p> required <code>y_current</code> <code>ndarray</code> <p>the current value of the <code>m N</code> vector of contracts</p> required <code>tau</code> <code>float</code> <p>scale factor</p> required <code>fix_top</code> <code>bool</code> <p>True if first-best imposed at top</p> <code>False</code> <code>free_y</code> <code>list | None</code> <p>a list of types for which we optimize over contracts</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>the minimizing <code>y</code>, an <code>m N</code>-vector</p> Source code in <code>multidim_screening_plain/solver.py</code> <pre><code>def prox_minusS(\n    model: ScreeningModel,\n    z: np.ndarray,\n    tau: float,\n    y_current: np.ndarray,\n    fix_top: bool = False,\n    free_y: list | None = None,\n) -&gt; np.ndarray:\n    \"\"\"Proximal operator of `-S(y) = sum_i f_i H(y_i, theta_i)`\n\n    Args:\n        model: the model\n        z: an `m N`-vector\n        y_current: the current value of the `m N` vector of contracts\n        tau: scale factor\n        fix_top: True if first-best imposed at top\n        free_y: a list of types for which we optimize over contracts\n\n    Returns:\n        the minimizing `y`, an `m N`-vector\n    \"\"\"\n    theta_mat = model.theta_mat\n    N = theta_mat.shape[0]\n    m = model.m\n    f = model.f\n\n    # these are the types we will be working with\n    Nmax = N - 1 if fix_top else N\n    working_i0 = [i for i in free_y if i &lt; Nmax] if free_y else list(range(Nmax))\n\n    list_working = [\n        [\n            model,\n            theta_mat[i, :],\n            np.array([z[k * N + i] for k in range(m)]),\n            tau * f[i],\n        ]\n        for i in working_i0\n    ]\n    n_working = len(list_working)\n\n    y = y_current.copy()\n    if fix_top:\n        # we fix the second-best at the first-best at the top\n        for k in range(m):\n            y[k * N + N - 1] = model.FB_y[-1, k]\n    # start_prox = perf_counter()\n    res = prox_work_func(model, list_working)\n    # end_prox = perf_counter()\n    # print(f\"\\n the proximal operator took {end_prox - start_prox: &gt; 10.5f} seconds\")\n    for i in range(n_working):\n        res_i = res[i]\n        i_working = working_i0[i]\n        for k in range(m):\n            y[i_working + k * N] = res_i[k]\n    return y\n</code></pre>"},{"location":"utils/","title":"<code>utils</code> module","text":""},{"location":"utils/#multidim_screening_plain.utils.H_fun","title":"<code>H_fun(argu)</code>","text":"<p>computes the function <code>H(x)=x*Phi(x)+phi(x)</code></p> <p>Parameters:</p> Name Type Description Default <code>argu</code> <code>ndarray | float</code> <p>must be an array or a float</p> required <p>Returns:</p> Type Description <code>ndarray | float</code> <p>an object of the same type and shape</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def H_fun(argu: np.ndarray | float) -&gt; np.ndarray | float:\n    \"\"\"computes the function `H(x)=x*Phi(x)+phi(x)`\n\n    Args:\n        argu:  must be an array or a float\n\n    Returns:\n        an object of the same type and shape\n    \"\"\"\n    return argu * bs_norm_cdf(argu) + bs_norm_pdf(argu)\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.L2_norm","title":"<code>L2_norm(x)</code>","text":"<p>Computes the L2 norm of a vector for numba</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def L2_norm(x: np.ndarray) -&gt; float:\n    \"\"\"Computes the L2 norm of a vector for numba\"\"\"\n    return sqrt(np.sum(x * x))\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.add_to_each_col","title":"<code>add_to_each_col(mat, vec)</code>","text":"<p>adds a vector to each column of a matrix</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>ndarray</code> <p>a \\((q, k)\\)-matrix</p> required <code>vec</code> <code>ndarray</code> <p>a \\(q\\)-vector</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>a \\((q, k)\\)-matrix, the result of adding <code>vec</code> to each column of <code>mat</code></p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def add_to_each_col(mat: np.ndarray, vec: np.ndarray) -&gt; np.ndarray:\n    \"\"\"adds a vector to each column of a matrix\n\n    Args:\n        mat: a $(q, k)$-matrix\n        vec: a $q$-vector\n\n    Returns:\n        a $(q, k)$-matrix, the result of adding `vec` to each column of `mat`\n    \"\"\"\n    q, k = mat.shape\n    c = np.empty((q, k))\n    for i in range(k):\n        c[:, i] = mat[:, i] + vec\n    return c\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.bs_norm_cdf","title":"<code>bs_norm_cdf(x)</code>","text":"<p>Fast standard normal CDF based on Numerical Recipes.</p> <p>This function is accurate to 6 decimal places.</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def bs_norm_cdf(x: np.ndarray | float) -&gt; np.ndarray | float:\n    \"\"\"Fast standard normal CDF based on Numerical Recipes.\n\n    This function is accurate to 6 decimal places.\n    \"\"\"\n    is_array = isinstance(x, np.ndarray)\n    a1 = 0.254829592\n    a2 = -0.284496736\n    a3 = 1.421413741\n    a4 = -1.453152027\n    a5 = 1.061405429\n    p = 0.3275911\n\n    z = x * INV_SQRT_2\n    if is_array:\n        sign_z = np.sign(z)\n        abs_z = np.abs(z)\n        ez2 = np.exp(-z * z)\n    else:\n        sign_z = 1 if z &gt; 0 else -1\n        abs_z = abs(z)\n        ez2 = exp(-z * z)\n    t = 1.0 / (1.0 + p * abs_z)\n    poly_t = ((((a5 * t + a4) * t) + a3) * t + a2) * t + a1\n    y = 1.0 - poly_t * t * ez2\n    res = (1.0 + sign_z * y) / 2.0\n\n    return cast(np.ndarray, res) if is_array else cast(float, res)\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.bs_norm_pdf","title":"<code>bs_norm_pdf(x)</code>","text":"<p>Fast standard normal PDF, the derivative of <code>bs_norm_cdf</code>.</p> <p>This function is accurate to 6 decimal places.</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def bs_norm_pdf(x: np.ndarray | float) -&gt; np.ndarray | float:\n    \"\"\"Fast standard normal PDF, the derivative of `bs_norm_cdf`.\n\n    This function is accurate to 6 decimal places.\n    \"\"\"\n    is_array = isinstance(x, np.ndarray)\n    a1 = 0.254829592\n    a2 = -0.284496736\n    a3 = 1.421413741\n    a4 = -1.453152027\n    a5 = 1.061405429\n    p = 0.3275911\n\n    z = x * INV_SQRT_2\n    if is_array:\n        sign_z = np.sign(z)\n        abs_z = np.abs(z)\n        ez2 = np.exp(-z * z)\n    else:\n        sign_z = 1 if z &gt; 0 else -1\n        abs_z = abs(z)\n        ez2 = exp(-z * z)\n\n    t = 1.0 / (1.0 + p * abs_z)\n    dt_dz = -t * t * p * sign_z\n    poly_t = ((((a5 * t + a4) * t) + a3) * t + a2) * t + a1\n    1.0 - poly_t * t * np.exp(-z * z)\n    dpoly_t = ((4.0 * a5 * t + 3.0 * a4) * t + 2.0 * a3) * t + a2\n    dy_dz = -((poly_t + t * dpoly_t) * dt_dz - 2.0 * z * poly_t * t) * ez2\n\n    res = sign_z * dy_dz * INV_SQRT_2 / 2.0\n\n    return cast(np.ndarray, res) if is_array else cast(float, res)\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.check_args","title":"<code>check_args(function_name, y, d, m, theta)</code>","text":"<p>check the arguments passed</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def check_args(\n    function_name: str,\n    y: np.ndarray,\n    d: int,\n    m: int,\n    theta: np.ndarray | None,\n) -&gt; None:\n    \"\"\"check the arguments passed\"\"\"\n    if theta is not None:\n        if theta.shape != (d,):\n            bs_error_abort(\n                f\"{function_name}: If theta is given it should be a {d}-vector, not\"\n                f\" shape {theta.shape}\"\n            )\n        if y.shape != (m,):\n            bs_error_abort(\n                f\"{function_name}: If theta is given, y should be a {m}-vector, not\"\n                f\" shape {y.shape}\"\n            )\n    else:\n        if y.ndim != 1:\n            bs_error_abort(\n                f\"{function_name}: y should be a vector, not {y.ndim}-dimensional\"\n            )\n        if y.size % m != 0:\n            bs_error_abort(\n                f\"{function_name}: y should have a number of elements multiple of {m},\"\n                f\" not {y.size}\"\n            )\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.contracts_matrix","title":"<code>contracts_matrix(y_vec, N)</code>","text":"<p>converts a vector of contracts to a matrix</p> <p>Parameters:</p> Name Type Description Default <code>y_vec</code> <code>ndarray</code> <p>an <code>m*N</code>vector (y[:,0] first, then y[:,1] etc)</p> required <p>Returns:</p> Name Type Description <code>y_mat</code> <code>ndarray</code> <p>an <code>(N,m)</code>-matrix</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def contracts_matrix(y_vec: np.ndarray, N: int) -&gt; np.ndarray:\n    \"\"\"converts a vector of contracts to a matrix\n\n    Args:\n        y_vec: an `m*N`vector (y[:,0] first, then y[:,1] etc)\n\n    Returns:\n        y_mat: an `(N,m)`-matrix\n    \"\"\"\n    m = y_vec.size // N\n    y_mat = np.empty((N, m))\n    for i in range(m):\n        y_mat[:, i] = y_vec[i * N : (i + 1) * N]\n    return cast(np.ndarray, y_mat)\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.contracts_vector","title":"<code>contracts_vector(y_mat)</code>","text":"<p>converts a matrix of contracts to a vector</p> <p>Parameters:</p> Name Type Description Default <code>y_mat</code> <code>ndarray</code> <p>an <code>(N,m)</code> matrix</p> required <p>Returns:</p> Name Type Description <code>y_vec</code> <code>ndarray</code> <p>an <code>m*N</code>-vector (y[:,0] first, then y[:,1] etc)</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def contracts_vector(y_mat: np.ndarray) -&gt; np.ndarray:\n    \"\"\"converts a matrix of contracts to a vector\n\n    Args:\n        y_mat: an `(N,m)` matrix\n\n    Returns:\n        y_vec: an `m*N`-vector (y[:,0] first, then y[:,1] etc)\n    \"\"\"\n    m = y_mat.shape[1]\n    y_vec = np.concatenate([y_mat[:, i] for i in range(m)])\n    return cast(np.ndarray, y_vec)\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.make_grid","title":"<code>make_grid(theta)</code>","text":"<p>creates the \\(d\\)-dimensional grid of types</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>list[ndarray]</code> <p>a list of \\(d\\) arrays</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>an \\((N,d)\\)-matrix, the grid of types</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def make_grid(theta: list[np.ndarray]) -&gt; np.ndarray:\n    \"\"\"\n    creates the $d$-dimensional grid of types\n\n    Args:\n        theta: a list of $d$ arrays\n\n    Returns:\n        an $(N,d)$-matrix, the grid of types\n    \"\"\"\n    ltheta = np.meshgrid(*theta)\n    d = len(ltheta)\n    for j in range(d):\n        ltheta[j] = ltheta[j].flatten()\n    N = ltheta[0].size\n    theta_mat = np.zeros((N, d))\n    for j in range(d):\n        theta_mat[:, j] = ltheta[j]\n    return theta_mat\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.multiply_each_col","title":"<code>multiply_each_col(mat, vec)</code>","text":"<p>multiplies each column of a matrix by a vector</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>ndarray</code> <p>a \\((q, k)\\)-matrix</p> required <code>vec</code> <code>ndarray</code> <p>a \\(q\\)-vector</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>a \\((q, k)\\)-matrix, the result of multiplying each column of <code>mat</code> by  <code>vec</code></p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def multiply_each_col(mat: np.ndarray, vec: np.ndarray) -&gt; np.ndarray:\n    \"\"\"multiplies each column of a matrix by a vector\n\n    Args:\n        mat: a $(q, k)$-matrix\n        vec: a $q$-vector\n\n    Returns:\n        a $(q, k)$-matrix, the result of multiplying each column of `mat` by  `vec`\n    \"\"\"\n    q, k = mat.shape\n    c = np.empty((q, k))\n    for i in range(k):\n        c[:, i] = mat[:, i] * vec\n    return c\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.my_outer_add","title":"<code>my_outer_add(a, b)</code>","text":"<p>outer sum of two vectors</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>ndarray</code> <p>a \\(q\\)-vector</p> required <code>b</code> <code>ndarray</code> <p>a \\(k\\)-vector</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>a \\((q,k)\\)-matrix, the outer sum of <code>a</code> and <code>b</code></p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def my_outer_add(a: np.ndarray, b: np.ndarray) -&gt; np.ndarray:\n    \"\"\"outer sum of two vectors\n\n    Args:\n        a: a $q$-vector\n        b: a $k$-vector\n\n    Returns:\n        a $(q,k)$-matrix, the outer sum of `a` and `b`\n    \"\"\"\n    q, k = a.size, b.size\n    c = np.empty((q, k))\n    for i in range(q):\n        c[i, :] = a[i] + b\n    return c\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.print_matrix","title":"<code>print_matrix(matrix)</code>","text":"<p>prints a matrix.</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def print_matrix(matrix: np.ndarray) -&gt; None:\n    \"\"\"prints a matrix.\"\"\"\n    for i in range(matrix.shape[0]):\n        print_row(matrix, i)\n    print(\"\\n\")\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.print_row","title":"<code>print_row(matrix, row)</code>","text":"<p>prints a row of a matrix.</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def print_row(matrix: np.ndarray, row: int) -&gt; None:\n    \"\"\"prints a row of a matrix.\"\"\"\n    print(\" \".join(f\"{matrix[row, j]: &gt; 10.4f}\" for j in range(matrix.shape[1])))\n</code></pre>"},{"location":"utils/#multidim_screening_plain.utils.split_y","title":"<code>split_y(y, m)</code>","text":"<p>Split y into <code>m</code> chunks of equal length</p> Source code in <code>multidim_screening_plain/utils.py</code> <pre><code>def split_y(y: np.ndarray, m: int) -&gt; list[np.ndarray]:\n    \"\"\"Split y into `m` chunks of equal length\"\"\"\n    N = y.size // m\n    y_chunks = [] * m\n    for j in range(m):\n        y_chunks.append(y[j * N : (j + 1) * N])\n    return y_chunks\n</code></pre>"}]}